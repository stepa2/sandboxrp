# BoxRP.UData

## Definitions
```
registered type .ObjectId = nonzero_uint31

fn .RegObject(objty: string, config: {
    Save: bool
    NetMode: array(string)
})

type .FieldType = 
    "bool"|"number"|"string"|"vector"|"angle"|"matrix"|"entity"|
    {"object"|"object_weak",string|nil --[[object type]]}

type .FieldValue =
    bool|number|string|Vector|Angle|VMatrix|Entity|.Object -- Only one matching .FieldType is allowed

fn .RegField(objty: string, key: string, config: {
    SaveOverride: bool|nil
    NetModeOverride: array(string)|nil

    Type: .FieldType
    Checker: nil|function(self, key = $key, val: nil|.FieldValue) -> bool  -- Additional checker

    -- Name of auto-generated getter
    -- Signature: fn(self) -> .FieldType
    AutoGetter: string|nil

    -- Name of auto-generated setter
    -- Signature: fn(self, value: .FieldType)  
    AutoSetter: string|nil
})

fn .RegTableObject(objty: string, config: {
    Save: bool
    NetMode: array(string)

    KeyType: "number"|"string"
    ValueType: .FieldType
    ValueChecker: nil|function(self, key: number|string, val: nil|.FieldValue) -> bool

    -- Name of auto-generated getter
    -- Signature: TODO
    AutoGetter: string|nil

    -- Name of auto-generated setter
    -- Signature: TODO  
    AutoSetter: string|nil
})

fn .RegNetMode(objty: string|nil, name: string, 
    recipents: fn(obj: .Object, recip: CRecipentFilter))

fn .GetMetatable(objty: string) -> table(any, any)

internal type .FieldDef = {
    SaveSv: nil|bool
    NetMode: nil|array(string)

    Type: .FieldType
    Checker: nil|function(self, key: number|string, val: nil|.FieldValue) -> bool

    AutoGetter: nil|string
    AutoSetter: nil|string
}

internal readonly var .ObjectDefs: table(objty: string, {
    Obj: {
        SaveSv: bool
        NetMode: array(string)
    }
    Fields: nil|table(key: string, .FieldDef)
    EveryField: nil|.FieldDef
    EveryFieldKey: nil|"number"|"string"
    Metatable: table(any, any)
})

internal fn .GetFieldDef(obj_ty: string, key: string|number) -> .FieldDef | nil

SV internal fn .GetRecipents(obj: .Object, netmodes: array(string)) -> CRecipentFilter
```

## Live Storage
```
internal fn ._Create(objtype: string, id: .ObjectId) -> .Object
-- If type not exists, it errors
SV fn .Create(objtype: string) -> .Object

fn .Load(id: .ObjectId) -> nil|.Object

SV fn .SaveAll()

readonly var .Objects: table(.ObjectId, .Object)

registered type .Object = {
    readonly var .Id: .ObjectId
    readonly var .Type: string

    fn :Raw_Get(key: string|number) -> .FieldValue|nil
    fn :Raw_Set(key: string|number, value: .FieldValue|nil)
    fn :Raw_Iterate() -> <iterator> key: string|number, value: .FieldValue
    -- Only works if .RegTableObject(...) was used
    fn :Raw_IterateArray() -> <iterator> index: number, value: .FieldValue

    SV fn :SendAll()

    fn :Unload()
    SV fn :DeleteUnload()

    -- Object is valid before :Unload() or :DeleteUnload() is called
    fn :IsValid() -> bool

    fn :__tostring() -> string

    <user metatable from BoxRP.UData.GetMetatable(self.Type), not-overriding>
    <auto-generated field getters/setters>

    readonly var .Raw = metatable {
        fn :__index(key: string|number) -> .FieldValue|nil
        fn :__newindex(key: string|number, value: .FieldValue|nil)
    }
}
```

## Networking

- `local fn _SendAll()`
  - `for oid, obj in pairs(.Objects) do obj:Send(true) end`
    - `for k, v in obj:Raw_Iterate() do ... end`
      - `local netmode = .GetFieldDef(obj.Type, k).NetMode or .ObjectDefs[obj.Type].Obj.NetMode`
      - `local recipents = .GetRecipents(obj, netmode)`
      - `net.Start(??)`
        - `net.Write??(oid)`
        - `net.Write??(k)`
        - `net.Write??(v)`
      - `net.Send(recipents)`

Serverside:  
- [Object-deleted hook handler] -> object netmessage
- [Object-created hook handler] -> object netmessage
- [Field-updated hook handler]  -> field netmessage

Clientside:
- [Object netmessage handler]
- [Field netmessage handler]

```
SV internal fn .SendField(obj: .Object, key: string|number, value: .FieldValue|nil)
SV internal fn .SendObjCreated(obj: .Object)
SV internal fn .SendObjUnloaded(obj: .Object)
```

## Database

```
SV internal fn .DB_RegisterField(objty: string, key: string, def: .FieldDef)
SV internal fn .DB_RegisterFieldEvery(objty: string, type: "string"|"number", def: .FieldDef)

SV internal fn .DB_RemoveAll()

SV internal fn .DB_CreateSaveObj(objty: string) -> .ObjectId
SV internal fn .DB_RemoveObj(ids: array(.ObjectId))
SV internal fn .DB_LoadObjRecursive(ids: array(.ObjectId)) -> array({id: .ObjectId, type: string})

-- Will return .ObjectId (number) for "object_weak"
SV internal fn .DB_LoadFields(ids: array(.ObjectId)) -> array({id: .ObjectId, key: string, value: .FieldValue})

SV internal fn .DB_SaveFields(fields: array({id: .ObjectId, key: string, value: .FieldValue|nil}))
```