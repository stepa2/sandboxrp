# BoxRP.UData

## Definitions
```
registered type .ObjectId = nonzero_uint31

const .OBJECT_ID_BITS = 31
const .OBJECT_ID_MAX: nonzero_uint31

registered type .FieldType = 
    "bool"|"number"|"string"|"vector"|"angle"|"matrix"|"entity"|
    {"object"|"object_lazy",string|nil --[[object type]]}

type .FieldValue =
    bool|number|string|Vector|Angle|VMatrix|Entity|.Object -- Only one matching .FieldType is allowed

fn .RegObject(objty: string, config: {
    Save: bool
    NetMode: array(string)
})

fn .RegField(objty: string, key: string, config: {
    SaveOverride: bool|nil
    NetModeOverride: array(string)|nil

    Type: .FieldType
    Checker: nil|function(obj: .Object, key = $key, val: nil|.FieldValue) -> bool  -- Additional checker

    -- Name of auto-generated getter
    -- Signature: fn(self) -> .FieldType|nil
    -- Boolean values are handled as nil, so you can use SERVER and "SomeName"
    AutoGetter: string|nil

    -- Name of auto-generated setter
    -- Signature: fn(self, value: .FieldType|nil, unchecked: bool|nil=false)  
    -- Boolean values are handled as nil, so you can use SERVER and "SomeName"
    AutoSetter: string|nil
})

fn .RegTableField(obkty: string, key: string, config: {
    Save: bool,
    NetMode: array(string),
    ValueType: .FieldType,
    ValueChecker: nil|function(obj: .Object, key: string, val: nil|.FieldValue) -> bool
})

fn .RegNetMode(objty: string|nil, name: string, 
    recipents: fn(obj: .Object, recip: CRecipentFilter))

fn .GetMetatable(objty: string) -> table(any, any)

internal type .FieldDef = {
    SaveSv: nil|bool
    NetMode: nil|array(string)|"everyone"

    Type: .FieldType
    Checker: nil|function(obj: .Object, key: string, val: nil|.FieldValue) -> bool

    AutoGetter: nil|string
    AutoSetter: nil|string
}

internal type .ObjectDef = {
    Obj: {
        SaveSv: bool
        NetMode: array(string)|"everyone"
    }
    Fields: nil|table(key: string, .FieldDef)
    EveryField: nil|.FieldDef
    Metatable: table(any, any)
}

internal readonly var .ObjectDefs: table(objty: string, .ObjectDef)

internal fn .GetFieldDef(objty: string, key: string) -> .FieldDef | nil

SV internal fn .GetRecipents(obj: .Object, netmodes: array(string)|"everyone") -> CRecipentFilter

internal fn bool .CheckFieldValue(value: nil|.FieldValue, type: .FieldType) -> bool
```

Pre-defined:
- Networking mode "everyone" - send to all players

## Live Storage
```
internal fn ._Create(objtype: string, id: .ObjectId) -> .Object
-- If type not exists, it errors
SV fn .Create(objtype: string) -> .Object


fn .FindByFieldValue(type: string, key: string|number, value: .FieldValue|nil, search_db: bool) -> array(.Object)

readonly var .Objects: table(.ObjectId, .Object)

<internal metatable .Object>
registered type .Object = {
    readonly var .Id: .ObjectId
    readonly var .Type: string

    fn :Raw_Get(key: string|number) -> .FieldValue|nil
    fn :Raw_Set(key: string|number, value: .FieldValue|nil, unchecked: bool|nil=false)
    -- full_load: if true, lazy-loaded objects will all be loaded ever if iteration stopped
    -- before reaching some of the objects.
    fn :Raw_Iterate(full_load: bool|nil=false) -> <iterator> -> key: string, value: .FieldValue
    fn :Raw_IterateArray(full_load: bool|nil=false) -> <iterator> -> index: number, value: .FieldValue

    fn :Unload()

    -- Object is valid before :Unload() or :DeleteUnload() is called
    fn :IsValid() -> bool

    fn :__tostring() -> string

    <user metatable from BoxRP.UData.GetMetatable(self.Type), not-overriding>
    <auto-generated field getters/setters>

    readonly var .Raw = metatable {
        fn :__index(key: string|number) -> .FieldValue|nil
        fn :__newindex(key: string|number, value: .FieldValue|nil)
    }

    internal var ._def: .ObjectDef
    internal var ._data: table(string, .FieldValue)
}

hook .FieldChanged(object: .Object, key: string, old: nil|.FieldValue, new: nil|.FieldValue)
hook .ObjectLoaded(object: .Object)
hook .ObjectPreUnloaded(object: .Object)

fn .RegHook(objty: string, key: string, hook_name: string, 
    callback: fn(obj: .Object, old: nil|.FieldValue, new: nil|.FieldValue))

fn .RegHookAll(objty: string, hook_name: string, 
    callback: fn(obj: .Object, key: string, old: nil|.FieldValue, new: nil|.FieldValue))
```

## Networking

## Database

```
SV internal fn .DB_RegisterField(objty: string, key: string, def: .FieldDef)
SV internal fn .DB_RegisterFieldEvery(objty: string, def: .FieldDef)

SV internal fn .DB_RemoveAll()

SV internal fn .DB_CreateSaveObj(objty: string) -> .ObjectId
SV internal fn .DB_RemoveObjs(ids: array(.ObjectId))
SV internal fn .DB_LoadObjRecursive(ids: array(.ObjectId)) -> array({id: .ObjectId, type: string})

SV internal fn .DB_LoadFields(ids: array(.ObjectId)) -> array({id: .ObjectId, key: string, value: string|number})

SV internal fn .DB_SaveFields(fields: array({id: .ObjectId, key: string, value: string|number|nil, is_objref: bool}))

-- Clears internal unsaved fields set, so do not call without using `out_fields`
SV internal fn .Object:_Save_GetData(out_fields: array({id: .ObjectId, key: string, value: string|number|nil, is_objref: bool}))

SV internal fn .DB_FindByField(objty: string, field_key: string, field_value: string|number|nil, is_objref: bool) 
    -> array({id: .ObjectId})
```

```
SV fn .Load(id: .ObjectId) -> nil|.Object
SV fn .LoadMany(ids: array(.ObjectId))

SV fn .SaveAll()

SV fn .Object:Save()
SV fn .Object:DeleteUnload()
```

## Utility

```
internal fn .Util_MemToSql(value: .FieldValue|nil, type: .FieldType) -> nil|string|number, is_objref: bool

-- Returns .ObjectId (number) if type is {"object_lazy",...}
internal fn .Util_SqlToMem(value: nil|string|number, type: .FieldType) -> .FieldValue|nil
```